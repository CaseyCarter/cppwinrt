// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.1.private

#include "pch.h"
#include "Language.h"
#include "Simple.h"
#include "Static.h"
#include "StructByRef.h"
#include "Nested.Simple.h"

namespace winrt::impl
{
    namespace
    {
        std::atomic<uint32_t> s_module_lock{};
    }

    module_lock::module_lock()
    {
        ++s_module_lock;
    }

    module_lock::~module_lock()
    {
        --s_module_lock;
    }
}

using namespace winrt;
using namespace Windows::Foundation;

HRESULT __stdcall DllCanUnloadNow()
{
    return impl::s_module_lock ? S_FALSE : S_OK;
}

HRESULT __stdcall DllGetActivationFactory(HSTRING classId, ::IUnknown** factory)
{
    try
    {
        wchar_t const* const name = WindowsGetStringRawBuffer(classId, nullptr);

        if (0 == wcscmp(name, L"Complex.Authoring.Language"))
        {
            *factory = detach_abi(make<Complex::Authoring::implementation::LanguageFactory>());
        }
        else if (0 == wcscmp(name, L"Complex.Authoring.Simple"))
        {
            *factory = detach_abi(make<Complex::Authoring::implementation::SimpleFactory>());
        }
        else if (0 == wcscmp(name, L"Complex.Authoring.Static"))
        {
            *factory = detach_abi(make<Complex::Authoring::implementation::StaticFactory>());
        }
        else if (0 == wcscmp(name, L"Complex.Authoring.StructByRef"))
        {
            *factory = detach_abi(make<Complex::Authoring::implementation::StructByRefFactory>());
        }
        else if (0 == wcscmp(name, L"Complex.Authoring.Nested.Simple"))
        {
            *factory = detach_abi(make<Complex::Authoring::Nested::implementation::SimpleFactory>());
        }
        else
        {
            throw hresult_class_not_available();
        }

        return S_OK;
    }
    catch (...)
    {
        *factory = nullptr;
        return impl::to_hresult();
    }
}
