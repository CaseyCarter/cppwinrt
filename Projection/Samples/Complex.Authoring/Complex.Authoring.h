// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.1.private

#pragma once
#include "winrt/base.h"

namespace winrt {

namespace Complex::Authoring {

struct ILanguage;
struct ISimple;
struct IStatic;
struct IStructByRef;
struct Language;
struct Simple;
struct Static;
struct StructByRef;

}

namespace Complex::Authoring::Composability::Closed {

struct IBase;
struct IBaseFactory;
struct IDerived;
struct Base;
struct Derived;

}

namespace Complex::Authoring::Composability::Open {

struct IBase;
struct IBaseFactory;
struct IDerived;
struct IDerivedFactory;
struct Base;
struct Derived;

}

namespace Complex::Authoring::Factory {

struct ISimple;
struct ISimpleFactory;
struct IStatic;
struct IStaticFactory;
struct Simple;
struct SimpleFactory;
struct Static;
struct StaticFactory;

}

namespace Complex::Authoring::Nested {

struct ISimple;
struct Simple;

}

namespace impl {

template <> struct category<Complex::Authoring::ILanguage>{ using type = interface_category; };
template <> struct category<Complex::Authoring::ISimple>{ using type = interface_category; };
template <> struct category<Complex::Authoring::IStatic>{ using type = interface_category; };
template <> struct category<Complex::Authoring::IStructByRef>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Language>{ using type = class_category; };
template <> struct category<Complex::Authoring::Simple>{ using type = class_category; };
template <> struct category<Complex::Authoring::Static>{ using type = class_category; };
template <> struct category<Complex::Authoring::StructByRef>{ using type = class_category; };
template <> struct name<Complex::Authoring::ILanguage>{ static constexpr auto & value{ L"Complex.Authoring.ILanguage" }; };
template <> struct name<Complex::Authoring::ISimple>{ static constexpr auto & value{ L"Complex.Authoring.ISimple" }; };
template <> struct name<Complex::Authoring::IStatic>{ static constexpr auto & value{ L"Complex.Authoring.IStatic" }; };
template <> struct name<Complex::Authoring::IStructByRef>{ static constexpr auto & value{ L"Complex.Authoring.IStructByRef" }; };
template <> struct name<Complex::Authoring::Language>{ static constexpr auto & value{ L"Complex.Authoring.Language" }; };
template <> struct name<Complex::Authoring::Simple>{ static constexpr auto & value{ L"Complex.Authoring.Simple" }; };
template <> struct name<Complex::Authoring::Static>{ static constexpr auto & value{ L"Complex.Authoring.Static" }; };
template <> struct name<Complex::Authoring::StructByRef>{ static constexpr auto & value{ L"Complex.Authoring.StructByRef" }; };
template <> struct guid<Complex::Authoring::ILanguage>{ static constexpr GUID value{ 0xC242F075,0x4BE5,0x4000,{ 0xB7,0x7E,0x56,0x34,0xBC,0x87,0x54,0x7F } }; };
template <> struct guid<Complex::Authoring::ISimple>{ static constexpr GUID value{ 0x09839E70,0xB064,0x4287,{ 0xA4,0x73,0x78,0x65,0x67,0x19,0xBA,0xDA } }; };
template <> struct guid<Complex::Authoring::IStatic>{ static constexpr GUID value{ 0xC242F075,0x4BE5,0x4000,{ 0xB7,0x7E,0x56,0x34,0xBC,0x87,0x54,0x7F } }; };
template <> struct guid<Complex::Authoring::IStructByRef>{ static constexpr GUID value{ 0x24EC9145,0x7F4B,0x4515,{ 0x89,0x10,0xEF,0x49,0x9B,0x26,0x7C,0x06 } }; };
template <> struct default_interface<Complex::Authoring::Language>{ using type = Complex::Authoring::ILanguage; };
template <> struct default_interface<Complex::Authoring::Simple>{ using type = Complex::Authoring::ISimple; };
template <> struct default_interface<Complex::Authoring::StructByRef>{ using type = Complex::Authoring::IStructByRef; };

template <typename D>
struct consume_Complex_Authoring_ILanguage
{
    hstring Français() const;
};
template <> struct consume<Complex::Authoring::ILanguage> { template <typename D> using type = consume_Complex_Authoring_ILanguage<D>; };

template <typename D>
struct consume_Complex_Authoring_ISimple
{
    hstring Name() const;
};
template <> struct consume<Complex::Authoring::ISimple> { template <typename D> using type = consume_Complex_Authoring_ISimple<D>; };

template <typename D>
struct consume_Complex_Authoring_IStatic
{
    Windows::Foundation::Rect Bounds() const;
};
template <> struct consume<Complex::Authoring::IStatic> { template <typename D> using type = consume_Complex_Authoring_IStatic<D>; };

template <typename D>
struct consume_Complex_Authoring_IStructByRef
{
    Windows::Foundation::Rect CopyByValue(Windows::Foundation::Rect const& byValue) const;
    Windows::Foundation::Rect CopyByRef(Windows::Foundation::Rect const& byRef) const;
};
template <> struct consume<Complex::Authoring::IStructByRef> { template <typename D> using type = consume_Complex_Authoring_IStructByRef<D>; };
template <> struct category<Complex::Authoring::Composability::Closed::IBase>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Composability::Closed::IBaseFactory>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Composability::Closed::IDerived>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Composability::Closed::Base>{ using type = class_category; };
template <> struct category<Complex::Authoring::Composability::Closed::Derived>{ using type = class_category; };
template <> struct name<Complex::Authoring::Composability::Closed::IBase>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Closed.IBase" }; };
template <> struct name<Complex::Authoring::Composability::Closed::IBaseFactory>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Closed.IBaseFactory" }; };
template <> struct name<Complex::Authoring::Composability::Closed::IDerived>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Closed.IDerived" }; };
template <> struct name<Complex::Authoring::Composability::Closed::Base>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Closed.Base" }; };
template <> struct name<Complex::Authoring::Composability::Closed::Derived>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Closed.Derived" }; };
template <> struct guid<Complex::Authoring::Composability::Closed::IBase>{ static constexpr GUID value{ 0x1C24DF03,0xC99E,0x41E2,{ 0x84,0x14,0x34,0x92,0x4D,0x3C,0xFD,0xE3 } }; };
template <> struct guid<Complex::Authoring::Composability::Closed::IBaseFactory>{ static constexpr GUID value{ 0x21E466E7,0x1B63,0x42C2,{ 0xAA,0x85,0x39,0x74,0xE4,0x42,0xB4,0xB2 } }; };
template <> struct guid<Complex::Authoring::Composability::Closed::IDerived>{ static constexpr GUID value{ 0x3AC15533,0xBD69,0x468C,{ 0xBB,0xD1,0x38,0x3E,0x2F,0x8C,0xD9,0x84 } }; };
template <> struct default_interface<Complex::Authoring::Composability::Closed::Base>{ using type = Complex::Authoring::Composability::Closed::IBase; };
template <> struct default_interface<Complex::Authoring::Composability::Closed::Derived>{ using type = Complex::Authoring::Composability::Closed::IDerived; };

template <typename D>
struct consume_Complex_Authoring_Composability_Closed_IBase
{
    void MethodOnBase() const;
};
template <> struct consume<Complex::Authoring::Composability::Closed::IBase> { template <typename D> using type = consume_Complex_Authoring_Composability_Closed_IBase<D>; };

template <typename D>
struct consume_Complex_Authoring_Composability_Closed_IBaseFactory
{
};
template <> struct consume<Complex::Authoring::Composability::Closed::IBaseFactory> { template <typename D> using type = consume_Complex_Authoring_Composability_Closed_IBaseFactory<D>; };

template <typename D>
struct consume_Complex_Authoring_Composability_Closed_IDerived
{
    void MethodOnDerived() const;
};
template <> struct consume<Complex::Authoring::Composability::Closed::IDerived> { template <typename D> using type = consume_Complex_Authoring_Composability_Closed_IDerived<D>; };
template <> struct category<Complex::Authoring::Composability::Open::IBase>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Composability::Open::IBaseFactory>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Composability::Open::IDerived>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Composability::Open::IDerivedFactory>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Composability::Open::Base>{ using type = class_category; };
template <> struct category<Complex::Authoring::Composability::Open::Derived>{ using type = class_category; };
template <> struct name<Complex::Authoring::Composability::Open::IBase>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Open.IBase" }; };
template <> struct name<Complex::Authoring::Composability::Open::IBaseFactory>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Open.IBaseFactory" }; };
template <> struct name<Complex::Authoring::Composability::Open::IDerived>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Open.IDerived" }; };
template <> struct name<Complex::Authoring::Composability::Open::IDerivedFactory>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Open.IDerivedFactory" }; };
template <> struct name<Complex::Authoring::Composability::Open::Base>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Open.Base" }; };
template <> struct name<Complex::Authoring::Composability::Open::Derived>{ static constexpr auto & value{ L"Complex.Authoring.Composability.Open.Derived" }; };
template <> struct guid<Complex::Authoring::Composability::Open::IBase>{ static constexpr GUID value{ 0x1C24DF03,0xC99E,0x41E2,{ 0x84,0x14,0x34,0x92,0x4D,0x3C,0xFD,0xE3 } }; };
template <> struct guid<Complex::Authoring::Composability::Open::IBaseFactory>{ static constexpr GUID value{ 0x21E466E7,0x1B63,0x42C2,{ 0xAA,0x85,0x39,0x74,0xE4,0x42,0xB4,0xB2 } }; };
template <> struct guid<Complex::Authoring::Composability::Open::IDerived>{ static constexpr GUID value{ 0x3AC15533,0xBD69,0x468C,{ 0xBB,0xD1,0x38,0x3E,0x2F,0x8C,0xD9,0x84 } }; };
template <> struct guid<Complex::Authoring::Composability::Open::IDerivedFactory>{ static constexpr GUID value{ 0xF950A4DB,0xDC20,0x47CB,{ 0x96,0xCF,0x6F,0x7D,0x89,0x5E,0x53,0xE6 } }; };
template <> struct default_interface<Complex::Authoring::Composability::Open::Base>{ using type = Complex::Authoring::Composability::Open::IBase; };
template <> struct default_interface<Complex::Authoring::Composability::Open::Derived>{ using type = Complex::Authoring::Composability::Open::IDerived; };

template <typename D>
struct consume_Complex_Authoring_Composability_Open_IBase
{
    void MethodOnBase() const;
};
template <> struct consume<Complex::Authoring::Composability::Open::IBase> { template <typename D> using type = consume_Complex_Authoring_Composability_Open_IBase<D>; };

template <typename D>
struct consume_Complex_Authoring_Composability_Open_IBaseFactory
{
    Complex::Authoring::Composability::Open::Base CreateInstance(Windows::Foundation::IInspectable const& outer, Windows::Foundation::IInspectable& inner) const;
};
template <> struct consume<Complex::Authoring::Composability::Open::IBaseFactory> { template <typename D> using type = consume_Complex_Authoring_Composability_Open_IBaseFactory<D>; };

template <typename D>
struct consume_Complex_Authoring_Composability_Open_IDerived
{
    void MethodOnDerived() const;
};
template <> struct consume<Complex::Authoring::Composability::Open::IDerived> { template <typename D> using type = consume_Complex_Authoring_Composability_Open_IDerived<D>; };

template <typename D>
struct consume_Complex_Authoring_Composability_Open_IDerivedFactory
{
    Complex::Authoring::Composability::Open::Derived CreateInstance(Windows::Foundation::IInspectable const& outer, Windows::Foundation::IInspectable& inner) const;
};
template <> struct consume<Complex::Authoring::Composability::Open::IDerivedFactory> { template <typename D> using type = consume_Complex_Authoring_Composability_Open_IDerivedFactory<D>; };
template <> struct category<Complex::Authoring::Factory::ISimple>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Factory::ISimpleFactory>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Factory::IStatic>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Factory::IStaticFactory>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Factory::Simple>{ using type = class_category; };
template <> struct category<Complex::Authoring::Factory::SimpleFactory>{ using type = class_category; };
template <> struct category<Complex::Authoring::Factory::Static>{ using type = class_category; };
template <> struct category<Complex::Authoring::Factory::StaticFactory>{ using type = class_category; };
template <> struct name<Complex::Authoring::Factory::ISimple>{ static constexpr auto & value{ L"Complex.Authoring.Factory.ISimple" }; };
template <> struct name<Complex::Authoring::Factory::ISimpleFactory>{ static constexpr auto & value{ L"Complex.Authoring.Factory.ISimpleFactory" }; };
template <> struct name<Complex::Authoring::Factory::IStatic>{ static constexpr auto & value{ L"Complex.Authoring.Factory.IStatic" }; };
template <> struct name<Complex::Authoring::Factory::IStaticFactory>{ static constexpr auto & value{ L"Complex.Authoring.Factory.IStaticFactory" }; };
template <> struct name<Complex::Authoring::Factory::Simple>{ static constexpr auto & value{ L"Complex.Authoring.Factory.Simple" }; };
template <> struct name<Complex::Authoring::Factory::SimpleFactory>{ static constexpr auto & value{ L"Complex.Authoring.Factory.SimpleFactory" }; };
template <> struct name<Complex::Authoring::Factory::Static>{ static constexpr auto & value{ L"Complex.Authoring.Factory.Static" }; };
template <> struct name<Complex::Authoring::Factory::StaticFactory>{ static constexpr auto & value{ L"Complex.Authoring.Factory.StaticFactory" }; };
template <> struct guid<Complex::Authoring::Factory::ISimple>{ static constexpr GUID value{ 0x68504FD7,0xF10E,0x4E7B,{ 0xB2,0xC5,0x2A,0x89,0x06,0x70,0xB3,0x9B } }; };
template <> struct guid<Complex::Authoring::Factory::ISimpleFactory>{ static constexpr GUID value{ 0x3590E075,0x41F5,0x4DBD,{ 0xA5,0xEA,0x30,0xDD,0x29,0x94,0xF8,0x84 } }; };
template <> struct guid<Complex::Authoring::Factory::IStatic>{ static constexpr GUID value{ 0x9987FDEA,0x6A97,0x41AD,{ 0x9B,0x9F,0x0F,0x27,0x4C,0xE0,0x77,0xD9 } }; };
template <> struct guid<Complex::Authoring::Factory::IStaticFactory>{ static constexpr GUID value{ 0xBFA00357,0x1F74,0x48C2,{ 0x9B,0xA2,0x37,0xAD,0x82,0x5A,0x63,0x9C } }; };
template <> struct default_interface<Complex::Authoring::Factory::Simple>{ using type = Complex::Authoring::Factory::ISimple; };
template <> struct default_interface<Complex::Authoring::Factory::SimpleFactory>{ using type = Complex::Authoring::Factory::ISimpleFactory; };

template <typename D>
struct consume_Complex_Authoring_Factory_ISimple
{
};
template <> struct consume<Complex::Authoring::Factory::ISimple> { template <typename D> using type = consume_Complex_Authoring_Factory_ISimple<D>; };

template <typename D>
struct consume_Complex_Authoring_Factory_ISimpleFactory
{
};
template <> struct consume<Complex::Authoring::Factory::ISimpleFactory> { template <typename D> using type = consume_Complex_Authoring_Factory_ISimpleFactory<D>; };

template <typename D>
struct consume_Complex_Authoring_Factory_IStatic
{
    void StaticMethod() const;
};
template <> struct consume<Complex::Authoring::Factory::IStatic> { template <typename D> using type = consume_Complex_Authoring_Factory_IStatic<D>; };

template <typename D>
struct consume_Complex_Authoring_Factory_IStaticFactory
{
    void StaticMethod() const;
};
template <> struct consume<Complex::Authoring::Factory::IStaticFactory> { template <typename D> using type = consume_Complex_Authoring_Factory_IStaticFactory<D>; };
template <> struct category<Complex::Authoring::Nested::ISimple>{ using type = interface_category; };
template <> struct category<Complex::Authoring::Nested::Simple>{ using type = class_category; };
template <> struct name<Complex::Authoring::Nested::ISimple>{ static constexpr auto & value{ L"Complex.Authoring.Nested.ISimple" }; };
template <> struct name<Complex::Authoring::Nested::Simple>{ static constexpr auto & value{ L"Complex.Authoring.Nested.Simple" }; };
template <> struct guid<Complex::Authoring::Nested::ISimple>{ static constexpr GUID value{ 0x34B0D9CC,0x0DBB,0x421C,{ 0xBA,0x71,0x7E,0x40,0xD0,0x96,0x68,0x04 } }; };
template <> struct default_interface<Complex::Authoring::Nested::Simple>{ using type = Complex::Authoring::Nested::ISimple; };

template <typename D>
struct consume_Complex_Authoring_Nested_ISimple
{
    hstring Name() const;
};
template <> struct consume<Complex::Authoring::Nested::ISimple> { template <typename D> using type = consume_Complex_Authoring_Nested_ISimple<D>; };

template <> struct abi<Complex::Authoring::ILanguage>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall get_Français(HSTRING* value) = 0;
};};

template <> struct abi<Complex::Authoring::ISimple>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall get_Name(HSTRING* value) = 0;
};};

template <> struct abi<Complex::Authoring::IStatic>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall get_Bounds(abi_t<Windows::Foundation::Rect>* value) = 0;
};};

template <> struct abi<Complex::Authoring::IStructByRef>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall CopyByValue(abi_t<Windows::Foundation::Rect> byValue, abi_t<Windows::Foundation::Rect>* result) = 0;
    virtual HRESULT __stdcall CopyByRef(abi_t<Windows::Foundation::Rect> const& byRef, abi_t<Windows::Foundation::Rect>* result) = 0;
};};

template <> struct abi<Complex::Authoring::Composability::Closed::IBase>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall MethodOnBase() = 0;
};};

template <> struct abi<Complex::Authoring::Composability::Closed::IBaseFactory>{ struct type : ::IInspectable
{
};};

template <> struct abi<Complex::Authoring::Composability::Closed::IDerived>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall MethodOnDerived() = 0;
};};

template <> struct abi<Complex::Authoring::Composability::Open::IBase>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall MethodOnBase() = 0;
};};

template <> struct abi<Complex::Authoring::Composability::Open::IBaseFactory>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall CreateInstance(::IUnknown* outer, ::IUnknown** inner, ::IUnknown** instance) = 0;
};};

template <> struct abi<Complex::Authoring::Composability::Open::IDerived>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall MethodOnDerived() = 0;
};};

template <> struct abi<Complex::Authoring::Composability::Open::IDerivedFactory>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall CreateInstance(::IUnknown* outer, ::IUnknown** inner, ::IUnknown** instance) = 0;
};};

template <> struct abi<Complex::Authoring::Factory::ISimple>{ struct type : ::IInspectable
{
};};

template <> struct abi<Complex::Authoring::Factory::ISimpleFactory>{ struct type : ::IInspectable
{
};};

template <> struct abi<Complex::Authoring::Factory::IStatic>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall StaticMethod() = 0;
};};

template <> struct abi<Complex::Authoring::Factory::IStaticFactory>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall StaticMethod() = 0;
};};

template <> struct abi<Complex::Authoring::Nested::ISimple>{ struct type : ::IInspectable
{
    virtual HRESULT __stdcall get_Name(HSTRING* value) = 0;
};};

}

namespace Complex::Authoring {

struct ILanguage :
    Windows::Foundation::IInspectable,
    impl::consume_t<ILanguage>
{
    ILanguage(std::nullptr_t = nullptr) noexcept {}
};

struct ISimple :
    Windows::Foundation::IInspectable,
    impl::consume_t<ISimple>
{
    ISimple(std::nullptr_t = nullptr) noexcept {}
};

struct IStatic :
    Windows::Foundation::IInspectable,
    impl::consume_t<IStatic>
{
    IStatic(std::nullptr_t = nullptr) noexcept {}
};

struct IStructByRef :
    Windows::Foundation::IInspectable,
    impl::consume_t<IStructByRef>
{
    IStructByRef(std::nullptr_t = nullptr) noexcept {}
};

}

namespace Complex::Authoring::Composability::Closed {

struct IBase :
    Windows::Foundation::IInspectable,
    impl::consume_t<IBase>
{
    IBase(std::nullptr_t = nullptr) noexcept {}
};

struct IBaseFactory :
    Windows::Foundation::IInspectable,
    impl::consume_t<IBaseFactory>
{
    IBaseFactory(std::nullptr_t = nullptr) noexcept {}
};

struct IDerived :
    Windows::Foundation::IInspectable,
    impl::consume_t<IDerived>
{
    IDerived(std::nullptr_t = nullptr) noexcept {}
};

}

namespace Complex::Authoring::Composability::Open {

struct IBase :
    Windows::Foundation::IInspectable,
    impl::consume_t<IBase>
{
    IBase(std::nullptr_t = nullptr) noexcept {}
};

struct IBaseFactory :
    Windows::Foundation::IInspectable,
    impl::consume_t<IBaseFactory>
{
    IBaseFactory(std::nullptr_t = nullptr) noexcept {}
};

struct IDerived :
    Windows::Foundation::IInspectable,
    impl::consume_t<IDerived>
{
    IDerived(std::nullptr_t = nullptr) noexcept {}
};

struct IDerivedFactory :
    Windows::Foundation::IInspectable,
    impl::consume_t<IDerivedFactory>
{
    IDerivedFactory(std::nullptr_t = nullptr) noexcept {}
};

}

namespace Complex::Authoring::Factory {

struct ISimple :
    Windows::Foundation::IInspectable,
    impl::consume_t<ISimple>
{
    ISimple(std::nullptr_t = nullptr) noexcept {}
};

struct ISimpleFactory :
    Windows::Foundation::IInspectable,
    impl::consume_t<ISimpleFactory>
{
    ISimpleFactory(std::nullptr_t = nullptr) noexcept {}
};

struct IStatic :
    Windows::Foundation::IInspectable,
    impl::consume_t<IStatic>
{
    IStatic(std::nullptr_t = nullptr) noexcept {}
};

struct IStaticFactory :
    Windows::Foundation::IInspectable,
    impl::consume_t<IStaticFactory>
{
    IStaticFactory(std::nullptr_t = nullptr) noexcept {}
};

}

namespace Complex::Authoring::Nested {

struct ISimple :
    Windows::Foundation::IInspectable,
    impl::consume_t<ISimple>
{
    ISimple(std::nullptr_t = nullptr) noexcept {}
};

}

namespace Complex::Authoring {

struct Language :
    Complex::Authoring::ILanguage
{
    Language(std::nullptr_t) noexcept {}
    Language();
};

struct Simple :
    Complex::Authoring::ISimple
{
    Simple(std::nullptr_t) noexcept {}
    Simple();
};

struct Static
{
    Static() = delete;
    static Windows::Foundation::Rect Bounds();
};

struct StructByRef :
    Complex::Authoring::IStructByRef
{
    StructByRef(std::nullptr_t) noexcept {}
    StructByRef();
};

}

namespace Complex::Authoring::Composability::Closed {

struct Base :
    Complex::Authoring::Composability::Closed::IBase
{
    Base(std::nullptr_t) noexcept {}
};

struct Derived :
    Complex::Authoring::Composability::Closed::IDerived,
    impl::base<Derived, Complex::Authoring::Composability::Closed::Base>,
    impl::require<Derived, Complex::Authoring::Composability::Closed::IBase>
{
    Derived(std::nullptr_t) noexcept {}
};

}

namespace Complex::Authoring::Composability::Open {

struct Base :
    Complex::Authoring::Composability::Open::IBase
{
    Base(std::nullptr_t) noexcept {}
};

struct Derived :
    Complex::Authoring::Composability::Open::IDerived,
    impl::base<Derived, Complex::Authoring::Composability::Open::Base>,
    impl::require<Derived, Complex::Authoring::Composability::Open::IBase>
{
    Derived(std::nullptr_t) noexcept {}
    Derived();
};

}

namespace Complex::Authoring::Factory {

struct Simple :
    Complex::Authoring::Factory::ISimple
{
    Simple(std::nullptr_t) noexcept {}
    Simple();
};

struct SimpleFactory :
    Complex::Authoring::Factory::ISimpleFactory
{
    SimpleFactory(std::nullptr_t) noexcept {}
    SimpleFactory();
};

struct Static
{
    Static() = delete;
    static void StaticMethod();
};

struct StaticFactory
{
    StaticFactory() = delete;
    static void StaticMethod();
};

}

namespace Complex::Authoring::Nested {

struct Simple :
    Complex::Authoring::Nested::ISimple
{
    Simple(std::nullptr_t) noexcept {}
    Simple();
};

}

namespace impl {

template <typename D> hstring consume_Complex_Authoring_ILanguage<D>::Français() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Complex::Authoring::ILanguage)->get_Français(put_abi(value)));
    return value;
}

template <typename D> hstring consume_Complex_Authoring_ISimple<D>::Name() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Complex::Authoring::ISimple)->get_Name(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::Rect consume_Complex_Authoring_IStatic<D>::Bounds() const
{
    Windows::Foundation::Rect value{};
    check_hresult(WINRT_SHIM(Complex::Authoring::IStatic)->get_Bounds(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::Rect consume_Complex_Authoring_IStructByRef<D>::CopyByValue(Windows::Foundation::Rect const& byValue) const
{
    Windows::Foundation::Rect result{};
    check_hresult(WINRT_SHIM(Complex::Authoring::IStructByRef)->CopyByValue(get_abi(byValue), put_abi(result)));
    return result;
}

template <typename D> Windows::Foundation::Rect consume_Complex_Authoring_IStructByRef<D>::CopyByRef(Windows::Foundation::Rect const& byRef) const
{
    Windows::Foundation::Rect result{};
    check_hresult(WINRT_SHIM(Complex::Authoring::IStructByRef)->CopyByRef(get_abi(byRef), put_abi(result)));
    return result;
}

template <typename D>
struct produce<D, Complex::Authoring::ILanguage> : produce_base<D, Complex::Authoring::ILanguage>
{
    HRESULT __stdcall get_Français(HSTRING* value) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_abi(this->shim().Français());
            return S_OK;
        }
        catch (...)
        {
            *value = nullptr;
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::ISimple> : produce_base<D, Complex::Authoring::ISimple>
{
    HRESULT __stdcall get_Name(HSTRING* value) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_abi(this->shim().Name());
            return S_OK;
        }
        catch (...)
        {
            *value = nullptr;
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::IStatic> : produce_base<D, Complex::Authoring::IStatic>
{
    HRESULT __stdcall get_Bounds(abi_t<Windows::Foundation::Rect>* value) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_abi(this->shim().Bounds());
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::IStructByRef> : produce_base<D, Complex::Authoring::IStructByRef>
{
    HRESULT __stdcall CopyByValue(abi_t<Windows::Foundation::Rect> byValue, abi_t<Windows::Foundation::Rect>* result) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_abi(this->shim().CopyByValue(*reinterpret_cast<Windows::Foundation::Rect const*>(&byValue)));
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }

    HRESULT __stdcall CopyByRef(abi_t<Windows::Foundation::Rect> const& byRef, abi_t<Windows::Foundation::Rect>* result) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_abi(this->shim().CopyByRef(*reinterpret_cast<Windows::Foundation::Rect const*>(&byRef)));
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D> void consume_Complex_Authoring_Composability_Closed_IBase<D>::MethodOnBase() const
{
    check_hresult(WINRT_SHIM(Complex::Authoring::Composability::Closed::IBase)->MethodOnBase());
}

template <typename D> void consume_Complex_Authoring_Composability_Closed_IDerived<D>::MethodOnDerived() const
{
    check_hresult(WINRT_SHIM(Complex::Authoring::Composability::Closed::IDerived)->MethodOnDerived());
}

template <typename D>
struct produce<D, Complex::Authoring::Composability::Closed::IBase> : produce_base<D, Complex::Authoring::Composability::Closed::IBase>
{
    HRESULT __stdcall MethodOnBase() noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MethodOnBase();
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::Composability::Closed::IBaseFactory> : produce_base<D, Complex::Authoring::Composability::Closed::IBaseFactory>
{};

template <typename D>
struct produce<D, Complex::Authoring::Composability::Closed::IDerived> : produce_base<D, Complex::Authoring::Composability::Closed::IDerived>
{
    HRESULT __stdcall MethodOnDerived() noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MethodOnDerived();
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D> void consume_Complex_Authoring_Composability_Open_IBase<D>::MethodOnBase() const
{
    check_hresult(WINRT_SHIM(Complex::Authoring::Composability::Open::IBase)->MethodOnBase());
}

template <typename D> Complex::Authoring::Composability::Open::Base consume_Complex_Authoring_Composability_Open_IBaseFactory<D>::CreateInstance(Windows::Foundation::IInspectable const& outer, Windows::Foundation::IInspectable& inner) const
{
    Complex::Authoring::Composability::Open::Base instance{ nullptr };
    check_hresult(WINRT_SHIM(Complex::Authoring::Composability::Open::IBaseFactory)->CreateInstance(get_abi(outer), put_abi(inner), put_abi(instance)));
    return instance;
}

template <typename D> void consume_Complex_Authoring_Composability_Open_IDerived<D>::MethodOnDerived() const
{
    check_hresult(WINRT_SHIM(Complex::Authoring::Composability::Open::IDerived)->MethodOnDerived());
}

template <typename D> Complex::Authoring::Composability::Open::Derived consume_Complex_Authoring_Composability_Open_IDerivedFactory<D>::CreateInstance(Windows::Foundation::IInspectable const& outer, Windows::Foundation::IInspectable& inner) const
{
    Complex::Authoring::Composability::Open::Derived instance{ nullptr };
    check_hresult(WINRT_SHIM(Complex::Authoring::Composability::Open::IDerivedFactory)->CreateInstance(get_abi(outer), put_abi(inner), put_abi(instance)));
    return instance;
}

template <typename D>
struct produce<D, Complex::Authoring::Composability::Open::IBase> : produce_base<D, Complex::Authoring::Composability::Open::IBase>
{
    HRESULT __stdcall MethodOnBase() noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MethodOnBase();
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::Composability::Open::IBaseFactory> : produce_base<D, Complex::Authoring::Composability::Open::IBaseFactory>
{
    HRESULT __stdcall CreateInstance(::IUnknown* outer, ::IUnknown** inner, ::IUnknown** instance) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            Windows::Foundation::IInspectable __local_inner;
            *instance = detach_abi(this->shim().CreateInstance(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&outer), __local_inner));
            if (inner) *inner = detach_abi(__local_inner);
            return S_OK;
        }
        catch (...)
        {
            if (inner) *inner = nullptr;
            *instance = nullptr;
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::Composability::Open::IDerived> : produce_base<D, Complex::Authoring::Composability::Open::IDerived>
{
    HRESULT __stdcall MethodOnDerived() noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MethodOnDerived();
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::Composability::Open::IDerivedFactory> : produce_base<D, Complex::Authoring::Composability::Open::IDerivedFactory>
{
    HRESULT __stdcall CreateInstance(::IUnknown* outer, ::IUnknown** inner, ::IUnknown** instance) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            Windows::Foundation::IInspectable __local_inner;
            *instance = detach_abi(this->shim().CreateInstance(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&outer), __local_inner));
            if (inner) *inner = detach_abi(__local_inner);
            return S_OK;
        }
        catch (...)
        {
            if (inner) *inner = nullptr;
            *instance = nullptr;
            return impl::to_hresult();
        }
    }
};

template <typename D> void consume_Complex_Authoring_Factory_IStatic<D>::StaticMethod() const
{
    check_hresult(WINRT_SHIM(Complex::Authoring::Factory::IStatic)->StaticMethod());
}

template <typename D> void consume_Complex_Authoring_Factory_IStaticFactory<D>::StaticMethod() const
{
    check_hresult(WINRT_SHIM(Complex::Authoring::Factory::IStaticFactory)->StaticMethod());
}

template <typename D>
struct produce<D, Complex::Authoring::Factory::ISimple> : produce_base<D, Complex::Authoring::Factory::ISimple>
{};

template <typename D>
struct produce<D, Complex::Authoring::Factory::ISimpleFactory> : produce_base<D, Complex::Authoring::Factory::ISimpleFactory>
{};

template <typename D>
struct produce<D, Complex::Authoring::Factory::IStatic> : produce_base<D, Complex::Authoring::Factory::IStatic>
{
    HRESULT __stdcall StaticMethod() noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StaticMethod();
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D>
struct produce<D, Complex::Authoring::Factory::IStaticFactory> : produce_base<D, Complex::Authoring::Factory::IStaticFactory>
{
    HRESULT __stdcall StaticMethod() noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StaticMethod();
            return S_OK;
        }
        catch (...)
        {
            return impl::to_hresult();
        }
    }
};

template <typename D> hstring consume_Complex_Authoring_Nested_ISimple<D>::Name() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Complex::Authoring::Nested::ISimple)->get_Name(put_abi(value)));
    return value;
}

template <typename D>
struct produce<D, Complex::Authoring::Nested::ISimple> : produce_base<D, Complex::Authoring::Nested::ISimple>
{
    HRESULT __stdcall get_Name(HSTRING* value) noexcept override
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_abi(this->shim().Name());
            return S_OK;
        }
        catch (...)
        {
            *value = nullptr;
            return impl::to_hresult();
        }
    }
};

}

namespace Complex::Authoring {

inline Language::Language() :
    Language(activate_instance<Language>())
{}

inline Simple::Simple() :
    Simple(activate_instance<Simple>())
{}

inline Windows::Foundation::Rect Static::Bounds()
{
    return get_activation_factory<Static, Complex::Authoring::IStatic>().Bounds();
}

inline StructByRef::StructByRef() :
    StructByRef(activate_instance<StructByRef>())
{}

}

namespace Complex::Authoring::Composability::Closed {

}

namespace Complex::Authoring::Composability::Open {

inline Derived::Derived()
{
    Windows::Foundation::IInspectable outer, inner;
    impl_move(get_activation_factory<Derived, Complex::Authoring::Composability::Open::IDerivedFactory>().CreateInstance(outer, inner));
}

template <typename D, typename ... Interfaces>
struct BaseT :
    implements<D, Windows::Foundation::IInspectable, composing, Interfaces ...>,
    impl::require<D, Complex::Authoring::Composability::Open::IBase>
{
    using composable = Base;

protected:
    BaseT()
    {
        get_activation_factory<Complex::Authoring::Composability::Open::Base, Complex::Authoring::Composability::Open::IBaseFactory>().CreateInstance(*this, this->m_inner);
    }
};

template <typename D, typename ... Interfaces>
struct DerivedT :
    implements<D, Windows::Foundation::IInspectable, composing, Interfaces ...>,
    impl::require<D, Complex::Authoring::Composability::Open::IDerived, Complex::Authoring::Composability::Open::IBase>
{
    using composable = Derived;

protected:
    DerivedT()
    {
        get_activation_factory<Complex::Authoring::Composability::Open::Derived, Complex::Authoring::Composability::Open::IDerivedFactory>().CreateInstance(*this, this->m_inner);
    }
};

}

namespace Complex::Authoring::Factory {

inline Simple::Simple() :
    Simple(activate_instance<Simple>())
{}

inline SimpleFactory::SimpleFactory() :
    SimpleFactory(activate_instance<SimpleFactory>())
{}

inline void Static::StaticMethod()
{
    get_activation_factory<Static, Complex::Authoring::Factory::IStatic>().StaticMethod();
}

inline void StaticFactory::StaticMethod()
{
    get_activation_factory<StaticFactory, Complex::Authoring::Factory::IStaticFactory>().StaticMethod();
}

}

namespace Complex::Authoring::Nested {

inline Simple::Simple() :
    Simple(activate_instance<Simple>())
{}

}

}

namespace std {

template<> struct hash<winrt::Complex::Authoring::ILanguage> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::ILanguage> {};

template<> struct hash<winrt::Complex::Authoring::ISimple> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::ISimple> {};

template<> struct hash<winrt::Complex::Authoring::IStatic> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::IStatic> {};

template<> struct hash<winrt::Complex::Authoring::IStructByRef> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::IStructByRef> {};

template<> struct hash<winrt::Complex::Authoring::Language> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Language> {};

template<> struct hash<winrt::Complex::Authoring::Simple> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Simple> {};

template<> struct hash<winrt::Complex::Authoring::Static> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Static> {};

template<> struct hash<winrt::Complex::Authoring::StructByRef> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::StructByRef> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Closed::IBase> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Closed::IBase> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Closed::IBaseFactory> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Closed::IBaseFactory> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Closed::IDerived> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Closed::IDerived> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Closed::Base> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Closed::Base> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Closed::Derived> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Closed::Derived> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Open::IBase> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Open::IBase> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Open::IBaseFactory> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Open::IBaseFactory> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Open::IDerived> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Open::IDerived> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Open::IDerivedFactory> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Open::IDerivedFactory> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Open::Base> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Open::Base> {};

template<> struct hash<winrt::Complex::Authoring::Composability::Open::Derived> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Composability::Open::Derived> {};

template<> struct hash<winrt::Complex::Authoring::Factory::ISimple> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::ISimple> {};

template<> struct hash<winrt::Complex::Authoring::Factory::ISimpleFactory> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::ISimpleFactory> {};

template<> struct hash<winrt::Complex::Authoring::Factory::IStatic> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::IStatic> {};

template<> struct hash<winrt::Complex::Authoring::Factory::IStaticFactory> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::IStaticFactory> {};

template<> struct hash<winrt::Complex::Authoring::Factory::Simple> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::Simple> {};

template<> struct hash<winrt::Complex::Authoring::Factory::SimpleFactory> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::SimpleFactory> {};

template<> struct hash<winrt::Complex::Authoring::Factory::Static> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::Static> {};

template<> struct hash<winrt::Complex::Authoring::Factory::StaticFactory> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Factory::StaticFactory> {};

template<> struct hash<winrt::Complex::Authoring::Nested::ISimple> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Nested::ISimple> {};

template<> struct hash<winrt::Complex::Authoring::Nested::Simple> : 
    winrt::impl::impl_hash_unknown<winrt::Complex::Authoring::Nested::Simple> {};

}
