// Copyright (c) Microsoft Corporation.
// All rights reserved.

import "unknwn.idl";
import "Windows.Foundation.idl";

//  This IDL file contains variations in types that are used to verify the MetadataType
//  infrastructure. The IMetadataTest interface has method signatures that show off various types
//  of parameters that may be encountered in metadata to confirm that we can correctly build the
//  metadata types for each. As such there should only ever be one parameter to each method and no
//  return type (the test code relies on this).
namespace TestMetadataTypes
{

    [version(1)]
    typedef enum TestEnum
    {
        MyEnumValue1 = 1,
        YourEnumValue2 = 2
    } TestEnum;

    [version(1)]
    [flags]
    typedef enum TestEnumFlags
    {
        MyEnumValue1 = 1,
        YourEnumValue2 = 2
    } TestEnumFlags;

    [version(1)]
    typedef struct TestStruct
    {
        INT16 simpleValue;
        Windows.Foundation.IReference<INT16> *genericValue;
        DOUBLE numericValue;
    } TestStruct;

    [version(1)]
    typedef struct TestStruct2
    {
        INT16 simpleValue;
        Windows.Foundation.IReference<TestStruct> *genericValue;
        DOUBLE numericValue;
    } TestStruct2;


    [version(1)]
    typedef struct TestStructNoReference
    {
        INT16 simpleValue;
        HSTRING stringValue;
        DOUBLE numericValue;
    } TestStructNoReference;

    [version(1)]
    [uuid(42962f2b-c39d-4b15-8f58-042ac40c0bdb)]
    interface IMagicNumberGenerator : IInspectable
    {
        HRESULT GetMagicNumber([out] UINT32 *pMagicNumber);
    }

    [version(1)]
    runtimeclass RMagicNumberGenerator
    {
        [default] interface IMagicNumberGenerator;
    }

    [version(1)]
    runtimeclass RcParameterizedDefault
    {
        [default] interface IVector<HSTRING>;
    }

    [version(1)]
    [uuid(5ad7a9d8-5292-4216-8b2c-5d63e30b60cd)]
    delegate HRESULT MagicNumberDelegate([out, retval]UINT32 *pMagicNumber);

    [version(1)]
    [uuid(86eeb1f7-636d-4016-8897-f9b933537702)]
    interface IMetadataTypeTestMethods : IInspectable
    {
        //  Fundamental types as [in] parameters
        HRESULT MethodByte([in]BYTE param1);
        HRESULT MethodSignedShort([in] INT16 param1);
        HRESULT MethodUnsignedShort([in] UINT16 param1);
        HRESULT MethodSignedInt([in] INT32 param1);
        HRESULT MethodUnsignedInt([in] UINT32 param1);
        HRESULT MethodFloat([in] float param1);
        HRESULT MethodDouble([in] double param1);
        HRESULT MethodString([in] HSTRING param1);
        HRESULT MethodBoolean([in] boolean param1);
        HRESULT MethodGuid([in] GUID param1);

        HRESULT MethodByteOut([out]BYTE *param1);
        HRESULT MethodSignedShortOut([out] INT16 *param1);
        HRESULT MethodUnsignedShortOut([out] UINT16 *param1);
        HRESULT MethodSignedIntOut([out] INT32 *param1);
        HRESULT MethodUnsignedIntOut([out] UINT32 *param1);
        HRESULT MethodFloatOut([out] float *param1);
        HRESULT MethodDoubleOut([out] double *param1);
        HRESULT MethodStringOut([out] HSTRING *param1);
        HRESULT MethodBooleanOut([out] boolean *param1);
        HRESULT MethodGuidOut([out] GUID *param1);
        HRESULT MethodArray([in] UINT32 cItems, [in, size_is(cItems)] DOUBLE *items);
        HRESULT MethodRC([in] RMagicNumberGenerator *pClass);
        HRESULT MethodRCParameterized([in] RcParameterizedDefault *pClass);
        HRESULT MethodRCOut([out] RMagicNumberGenerator **pClass);
        HRESULT MethodRCParameterizedOutOut([out] RcParameterizedDefault **pClass);

        // User-defined types as [in] parameters
        HRESULT MethodEnum([in] TestEnum param1);
        HRESULT MethodStruct([in] TestStruct param1);
        HRESULT MethodIInspectable([in] IInspectable *pParam1);

        HRESULT MethodEnumOut([out] TestEnum *param1);
        HRESULT MethodStructOut([out] TestStruct *param1);
        HRESULT MethodIInspectableOut([out] IInspectable **pParam1);

        // Array patterns
        HRESULT MethodFillArray([in, range(0, 10)] UINT32 cItems,
                                [out, size_is(cItems)] boolean *items);

        HRESULT MethodPassArray([in, range(0, 10)] UINT32 cItems,
                                [in, size_is(cItems)] UINT32 *items);

        HRESULT MethodReceiveArray([out] UINT32 *pcSize,
                                   [out, size_is(,*pcSize)] UINT32 **items);

        // Pinterfaces
        HRESULT MethodPinterfaceIn([in] IVector<UINT32> *pVector);
        HRESULT MethodPinterfaceOut([out] IMap<UINT32, IInspectable*> **ppParam1);
    }

    [version(1)]
    runtimeclass RCThoroughInterface
    {
        [default] interface IMetadataTypeTestMethods;
    }

    [version(1)]
    [uuid(c842b307-dcad-4e6d-aa7a-c53295d77ceb)]
    interface IMetadataMethodParameterVariations : IInspectable
    {
        HRESULT EmptyMethod();
        HRESULT MethodByte([in]BYTE param1);
        HRESULT MethodSignedShort([in] INT16 param1);
        HRESULT MethodUnsignedShort([in] UINT16 param1);
        HRESULT MethodSignedInt([in] INT32 param1);
        HRESULT MethodUnsignedInt([in] UINT32 param1);
        HRESULT MethodFloat([in] float param1);
        HRESULT MethodDouble([in] double param1);
        HRESULT MethodString([in] HSTRING param1);
        HRESULT MethodBoolean([in] boolean param1);
        HRESULT MethodGuid([in] GUID param1);
        HRESULT MethodEventRegistrationToken([in] EventRegistrationToken param1);
        HRESULT MethodAsyncStatus([in] AsyncStatus param1);

        // User-defined types as [in] parameters
        HRESULT MethodEnum([in] TestEnum param1);
        HRESULT MethodStruct([in] TestStruct param1);
        HRESULT MethodIInspectable([in] IInspectable *pParam1);
        HRESULT MethodRC([in] RMagicNumberGenerator *pClass);
        HRESULT MethodRCPDefault([in] RcParameterizedDefault *pClass);

        HRESULT MethodByteOut([out]BYTE *param1);
        HRESULT MethodSignedShortOut([out] INT16 *param1);
        HRESULT MethodUnsignedShortOut([out] UINT16 *param1);
        HRESULT MethodSignedIntOut([out] INT32 *param1);
        HRESULT MethodUnsignedIntOut([out] UINT32 *param1);
        HRESULT MethodFloatOut([out] float *param1);
        HRESULT MethodDoubleOut([out] double *param1);
        HRESULT MethodStringOut([out] HSTRING *param1);
        HRESULT MethodBooleanOut([out] boolean *param1);
        HRESULT MethodGuidOut([out] GUID *param1);
        HRESULT MethodRCPDefaultOut([out] RcParameterizedDefault **pClass);

        HRESULT MethodEnumOut([out] TestEnum *param1);
        HRESULT MethodStructOut([out] TestStruct *param1);
        HRESULT MethodIInspectableOut([out] IInspectable **pParam1);
        HRESULT MethodRCOut([out] RMagicNumberGenerator **pClass);

        HRESULT MultiParameterMethods([in] float param1, [in] RMagicNumberGenerator *pClass, [out] UINT32 *outParam1);
        HRESULT MultiParameterMethods2([in] HSTRING param1, [in] TestStruct pClass, [in]int intVal, [out] UINT32 *outParam1, [out] GUID *guidOut);
        HRESULT MethodFourBools([in] boolean param1,[in] boolean param2,[in] boolean param3,[in] boolean param4);

        HRESULT ReturnValueInt([out, retval]int *value);
        HRESULT ReturnValueString([out, retval]HSTRING *value);
        HRESULT ReturnValueClass([out, retval]RMagicNumberGenerator **value);
        HRESULT ParametersAndReturnValues([in]HSTRING stringParam, [in]double doubleParam, [out, retval]RMagicNumberGenerator **value);

        // Pinterfaces
        HRESULT MethodPinterfaceIn([in] IVector<UINT32> *pVector);
        HRESULT MethodPinterfaceOut([out] IMap<UINT32, IInspectable*> **ppParam1);

        // Array patterns
        HRESULT MethodFillArray([in, range(0, 10)] UINT32 cItems, [out, size_is(cItems)] boolean *items);
        HRESULT MethodPassArray([in, range(0, 10)] UINT32 cItems, [in, size_is(cItems)] UINT32 *items);
        HRESULT MethodReceiveArray([out] UINT32 *pcSize, [out, size_is(,*pcSize)] UINT32 **items);

        HRESULT MethodReceiveArrayRetVal([out] UINT32 *pcSize, [out, retval, size_is(,*pcSize)] UINT32 **items);

        HRESULT MethodFillArrayWithLength([in, range(0, 10)] UINT32 cItems, [out, size_is(cItems), length_is(*pcLength)] boolean *items, [out]UINT32 *pcLength);
        HRESULT MethodReceiveArrayWithLength([out] UINT32 *pcSize, [out, size_is(,*pcSize), length_is(,*pcLength)] UINT32 **items, [out]UINT32 *pcLength);

        //  Array patterns 2.
        HRESULT Write([in] UINT32 byteCount, [in, size_is(byteCount)] const BYTE *buffer );
        HRESULT WritePartial([in] UINT32 byteCount,[in, size_is(byteCount)] const BYTE *buffer, [out, retval] DWORD *result);
        HRESULT Read([in, range(0, 65535)] UINT32 desiredByteCount,[out, size_is(desiredByteCount)] BYTE *buffer);
        HRESULT ReadPartial([in, range(0, 2147483647 )] UINT32 desiredByteCount,[out, size_is(desiredByteCount)] BYTE *buffer,[out, retval] DWORD *result);
        HRESULT WriteRead([in] UINT32 writeBufferLength,[in, size_is(writeBufferLength)] const BYTE *writeBuffer,[in, range(0, 2147483647)] UINT32 desiredByteCount,[out, size_is(desiredByteCount)] BYTE *readBuffer);
        HRESULT WriteReadPartial([in] UINT32 writeBufferLength,[in, size_is(writeBufferLength)] const BYTE *writeBuffer,[in, range(0, 2147483647)] UINT32 desiredByteCount,[out, size_is(desiredByteCount)] BYTE *readBuffer,[out, retval] DWORD *result);
    }

    declare
    {
        interface IVector<boolean>;
        //interface IVector<GUID>;
        interface IVector<IKeyValuePair<HSTRING, HSTRING>*>;
        interface IVector<TestStructNoReference>;
        interface IVector<TestEnum>;
        interface IVector<TestStruct>;
        interface Windows.Foundation.IAsyncActionWithProgress<RcParameterizedDefault>;
    }

    [uuid(97aecbab-efff-4ebb-9ed8-cc5b19ade92e)]
    [version(1)]
    interface IParameterizedInterfaceBaseTypeVariations : IInspectable
    {
        HRESULT PInterfaceBaseTypeBoolean([in] IVector<boolean> *param1);
        HRESULT PInterfaceBaseTypeByte([in]IVector<BYTE> *param1);
        HRESULT PInterfaceBaseTypeWchar([in]IVector<wchar_t> *param1);
        HRESULT PInterfaceBaseTypeSignedShort([in] IVector<INT16> *param1);
        HRESULT PInterfaceBaseTypeUnsignedShort([in] IVector<UINT16> *param1);
        HRESULT PInterfaceBaseTypeSignedInt([in] IVector<INT32> *param1);
        HRESULT PInterfaceBaseTypeUnsignedInt([in] IVector<UINT32> *param1);
        HRESULT PInterfaceBaseTypeInt64([in] IVector<INT64> *param1);
        HRESULT PInterfaceBaseTypeUInt64([in] IVector<UINT64> *param1);
        HRESULT PInterfaceBaseTypeFloat([in] IVector<float> *param1);
        HRESULT PInterfaceBaseTypeDouble([in] IVector<double> *param1);
        HRESULT PInterfaceBaseTypeString([in] IVector<HSTRING> *param1);
        HRESULT PInterfaceBaseTypeGuid([in] IVector<GUID> *param1);
        HRESULT PInterfaceBaseTypeObject([in] IVector<IInspectable *> *param1);

        HRESULT PInterfaceEnumType([in] IVector<TestEnum> *param1);
        HRESULT PInterfaceEnumTypeFlags([in] IVector<TestEnumFlags> *param1);
        HRESULT PInterfaceStructTypeNoReference([in] IVector<TestStructNoReference> *param1);
        HRESULT PInterfaceStructTypeReference([in] IVector<TestStruct> *param1);
        HRESULT PInterfaceStructTypeReference2([in] IVector<TestStruct2> *param1);

        HRESULT PInterfaceOfMapEnumToStruct([in] IMap<TestEnum, TestStruct> *param1);
        HRESULT PInterfaceOfInterface([in]IVector<IMagicNumberGenerator> *param1);
        HRESULT PInterfaceOfDelegate([in]IVector<MagicNumberDelegate> *param1);
        HRESULT PInterfaceOfRuntimeClasses([in]IVector<RMagicNumberGenerator> *param1);
        HRESULT PInterfaceOfRCPInterfaceDefault([in] IVector<RcParameterizedDefault> *pClass);

        HRESULT PInterfaceOfPinterface1([in]IVector<IMap<HSTRING, TestStruct2> *> *param1);

        HRESULT PInterfaceOfReference1([in]Windows.Foundation.IReference<UINT32> *param1);
        HRESULT PInterfaceOfReference2([in]Windows.Foundation.IReference<TestStruct> *param1);
        HRESULT PInterfaceOfReference3([in]Windows.Foundation.IReference<TestEnum> *param1);

        HRESULT IVectorView([in]IVectorView<HSTRING> *param1);
        HRESULT IIterable([in]IIterable<HSTRING> *param1);
        HRESULT IIterator([in]IIterator<HSTRING> *param1);
        HRESULT IKeyValuePair([in]IKeyValuePair<HSTRING, UINT32> *param1);
        HRESULT IObservableMap([in]IObservableMap<HSTRING, UINT32> *param1);
        HRESULT EventHandler([in]Windows.Foundation.EventHandler<UINT32> *param1);
        HRESULT TypedEventHandler([in]Windows.Foundation.TypedEventHandler<UINT32, HSTRING> *param1);
        HRESULT AsyncOperationProgress([in]Windows.Foundation.IAsyncOperationWithProgress<UINT32, HSTRING> *param1);
        HRESULT AsyncOperationProgressCompletedHandler([in]Windows.Foundation.AsyncOperationWithProgressCompletedHandler<UINT32, HSTRING> *param1);
        HRESULT AsyncOperation([in]Windows.Foundation.IAsyncOperation<TestEnum> *param1);
        HRESULT AsyncOperationCompletedHandler([in]Windows.Foundation.AsyncOperationCompletedHandler<TestEnum> *param1);
        HRESULT AsyncActionProgressHandler([in]Windows.Foundation.AsyncActionProgressHandler<double> *param1);
        HRESULT AsyncActionProgressCompletedHandler([in]Windows.Foundation.AsyncActionWithProgressCompletedHandler<double> *param1);
        HRESULT AsyncActionWithProgressOperation([in]Windows.Foundation.IAsyncActionWithProgress<RcParameterizedDefault> *param1);
        HRESULT VectorOfKeyValuePairOfTwoStrings([in]Windows.Foundation.Collections.IVector<IKeyValuePair<HSTRING, HSTRING>*> *param1);

    }
}

